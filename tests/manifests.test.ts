import { describe, it, expect, vi, afterEach } from "vitest";
import {
  parsePackageJson,
  parsePackageLockJson,
  parseRequirementsTxt,
  parseCargoLock,
  parseManifest,
} from "../src/extractors/manifests.js";
import { scanManifest } from "../src/dep-scan.js";
import { writeFile, mkdir, rm } from "fs/promises";
import { join } from "path";
import { tmpdir } from "os";

const TEST_DIR = join(tmpdir(), `flare-manifest-test-${process.pid}`);

afterEach(async () => {
  vi.restoreAllMocks();
  await rm(TEST_DIR, { recursive: true, force: true });
});

describe("parsePackageJson", () => {
  it("extracts dependencies with pinned versions", () => {
    const content = JSON.stringify({
      dependencies: {
        express: "4.18.2",
        lodash: "^4.17.21",
      },
      devDependencies: {
        vitest: "~1.2.3",
      },
    });
    const result = parsePackageJson(content);
    expect(result).toHaveLength(3);
    expect(result[0]).toMatchObject({ name: "express", version: "4.18.2", ecosystem: "npm" });
    expect(result[1]).toMatchObject({ name: "lodash", version: "4.17.21", ecosystem: "npm" });
    expect(result[2]).toMatchObject({ name: "vitest", version: "1.2.3", ecosystem: "npm" });
  });

  it("skips ranges without semver", () => {
    const content = JSON.stringify({
      dependencies: {
        pkg: "*",
        other: "latest",
      },
    });
    const result = parsePackageJson(content);
    expect(result).toHaveLength(0);
  });

  it("handles malformed JSON gracefully", () => {
    const result = parsePackageJson("not json");
    expect(result).toHaveLength(0);
  });
});

describe("parsePackageLockJson", () => {
  it("parses v2/v3 format", () => {
    const content = JSON.stringify({
      lockfileVersion: 3,
      packages: {
        "": { name: "my-app", version: "1.0.0" },
        "node_modules/express": { version: "4.18.2" },
        "node_modules/lodash": { version: "4.17.21" },
      },
    });
    const result = parsePackageLockJson(content);
    expect(result).toHaveLength(2);
    expect(result[0]).toMatchObject({ name: "express", version: "4.18.2" });
    expect(result[1]).toMatchObject({ name: "lodash", version: "4.17.21" });
  });

  it("parses v1 format", () => {
    const content = JSON.stringify({
      lockfileVersion: 1,
      dependencies: {
        express: { version: "4.18.2" },
        lodash: { version: "4.17.21" },
      },
    });
    const result = parsePackageLockJson(content);
    expect(result).toHaveLength(2);
  });
});

describe("parseRequirementsTxt", () => {
  it("extracts pinned packages", () => {
    const content = `
# This is a comment
flask==2.3.0
requests==2.28.1
-r other-requirements.txt
numpy>=1.24.0
pandas==2.0.0
`;
    const result = parseRequirementsTxt(content);
    expect(result).toHaveLength(3);
    expect(result[0]).toMatchObject({ name: "flask", version: "2.3.0", ecosystem: "PyPI" });
    expect(result[1]).toMatchObject({ name: "requests", version: "2.28.1" });
    expect(result[2]).toMatchObject({ name: "pandas", version: "2.0.0" });
  });

  it("skips unpinned packages", () => {
    const content = `flask\nrequests>=2.0`;
    const result = parseRequirementsTxt(content);
    expect(result).toHaveLength(0);
  });
});

describe("parseCargoLock", () => {
  it("extracts package entries", () => {
    const content = `# This file is automatically generated
[[package]]
name = "serde"
version = "1.0.193"
source = "registry+https://github.com/rust-lang/crates.io-index"

[[package]]
name = "tokio"
version = "1.35.0"
`;
    const result = parseCargoLock(content);
    expect(result).toHaveLength(2);
    expect(result[0]).toMatchObject({ name: "serde", version: "1.0.193", ecosystem: "crates.io" });
    expect(result[1]).toMatchObject({ name: "tokio", version: "1.35.0" });
  });
});

describe("parseManifest", () => {
  it("auto-detects package.json", () => {
    const content = JSON.stringify({ dependencies: { express: "4.18.2" } });
    const result = parseManifest("package.json", content);
    expect(result).toHaveLength(1);
  });

  it("auto-detects requirements.txt", () => {
    const result = parseManifest("requirements.txt", "flask==2.3.0");
    expect(result).toHaveLength(1);
  });

  it("returns empty for unknown files", () => {
    const result = parseManifest("readme.md", "some content");
    expect(result).toHaveLength(0);
  });
});

describe("scanManifest with mocked OSV", () => {
  function mockOsv(response: object, status = 200) {
    return vi.spyOn(globalThis, "fetch").mockResolvedValue({
      ok: status >= 200 && status < 300,
      json: async () => response,
    } as Response);
  }

  it("reports vulnerable packages", async () => {
    mockOsv({
      vulns: [
        { id: "CVE-2024-1234", severity: [{ type: "CVSS_V3", score: "9.8" }] },
      ],
    });

    const dir = join(TEST_DIR, "vuln-scan");
    await mkdir(dir, { recursive: true });
    const filePath = join(dir, "requirements.txt");
    await writeFile(filePath, "flask==2.0.0\nrequests==2.19.1\n", "utf-8");

    const result = await scanManifest(filePath, 1500, new Set());
    expect(result.packages_scanned).toBe(2);
    expect(result.findings.length).toBeGreaterThanOrEqual(1);
    expect(result.findings[0].category).toBe("package-vulnerability");
    expect(result.findings[0].source).toBeDefined();
    expect(result.findings[0].source!.file).toBe(filePath);
  });

  it("reports no findings for clean packages", async () => {
    mockOsv({ vulns: [] });

    const dir = join(TEST_DIR, "clean-scan");
    await mkdir(dir, { recursive: true });
    const filePath = join(dir, "requirements.txt");
    await writeFile(filePath, "flask==3.0.0\n", "utf-8");

    const result = await scanManifest(filePath, 1500, new Set());
    expect(result.packages_scanned).toBe(1);
    expect(result.findings).toHaveLength(0);
  });

  it("respects allowlist", async () => {
    const spy = mockOsv({
      vulns: [{ id: "CVE-2024-9999", severity: [{ type: "CVSS_V3", score: "9.8" }] }],
    });

    const dir = join(TEST_DIR, "allow-scan");
    await mkdir(dir, { recursive: true });
    const filePath = join(dir, "requirements.txt");
    await writeFile(filePath, "flask==2.0.0\n", "utf-8");

    const result = await scanManifest(filePath, 1500, new Set(["flask"]));
    expect(spy).not.toHaveBeenCalled();
    expect(result.findings).toHaveLength(0);
  });
});
